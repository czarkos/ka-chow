{{include_text('defines.yaml')}}

architecture:
  nodes: &macro # TOP MACRO
  # ===========================================================================
  - !Container # Macro top-level
    name: macro
    <<<: [*container_defaults]

  {{ignoreme_placeholder | default('') | indent(2)}}

  # TODO : Decide what to do with memories
  - !Component # Weight cache stores weights
    name: input_cache
    <<<: [*component_defaults, *keep_inputs]
    subclass: lightning_sram
    attributes:
      depth: 4096
      width: 64
      datawidth: 8               # To ensure that we can run weight-stationary
      multiple_buffering: 0.0001 # (as assumed in the Albireo paper)
    constraints: 
      temporal: 
        factors_only: [M=-1]
        factors: []
        no_iteration_over_dataspaces: !nomerge [] # Overwrite default

  - !Component # Weight cache stores weights
    name: weight_cache
    <<<: [*component_defaults, *keep_weights]
    subclass: lightning_sram
    attributes:
      depth: 4096
      width: 64
      datawidth: 8               # To ensure that we can run weight-stationary
      multiple_buffering: 0.0001 # (as assumed in the Albireo paper)
    constraints: 
      temporal: 
        factors_only: [M=-1]
        factors: []
        no_iteration_over_dataspaces: !nomerge [] # Overwrite default

  - !Component # Weight cache stores weights
    name: output_cache
    <<<: [*component_defaults, *keep_outputs]
    subclass: lightning_sram
    attributes:
      depth: 4096
      width: 64
      datawidth: 8               # To ensure that we can run weight-stationary
      multiple_buffering: 0.0001 # (as assumed in the Albireo paper)
    constraints: 
      temporal: 
        factors_only: [M=-1]
        factors: []
        no_iteration_over_dataspaces: !nomerge [] # Overwrite default

  # TODO : Decide where to put the laser
  #- !Component # Row drivers feed inputs onto the rows of the array
  # name: laser
  #  <<<: [*component_defaults, *keep_weights, *no_coalesce]
  #  subclass: lightning_laser
  #  attributes: {<<: *cim_component_attributes}
  
  - !Component # Row drivers feed inputs onto the rows of the array
    name: weight_dacs
    <<<: [*component_defaults, *keep_weights, *no_coalesce]
    subclass: dac_lightning
    attributes: {width: DAC_RESOLUTION, n_instances: NUM_PARALLEL_WEIGHTS*NUM_WAVELENGTHS}
  
  - !Component # Row drivers feed inputs onto the rows of the array
    name: weight_modulators
    <<<: [*component_defaults, *keep_weights, *no_coalesce]
    subclass: lightning_modulator
    attributes: {width: DAC_RESOLUTION, n_instances: NUM_PARALLEL_WEIGHTS*NUM_WAVELENGTHS}

  - !ArrayContainer # Each column stores a different weight slice. Columns share inputs.
    name: IMU
    <<<: [*container_defaults, *spatial_must_reuse_weights]
    spatial: {meshX: BATCH_SIZE}
    constraints: {spatial: {maximize_dims: []}}
    max_utilization: {spatial: {factors: [('M=' + str(IMU.get_fanout()))]}}

  - !Component # Column readout (ADC)
    name: adc
    <<<: [*component_defaults, *keep_outputs, *no_coalesce]
    subclass: adc_lightning
    attributes: {width: ENCODED_OUTPUT_BITS, <<<: *cim_component_attributes, n_instances: NUM_PARALLEL_WEIGHTS}

  - !Component # Photodetectors
    name: photodetector
    <<<: [*component_defaults, *keep_outputs, *no_coalesce]
    subclass: lightning_photodiode
    attributes: {width: ENCODED_OUTPUT_BITS, <<<: *cim_component_attributes, n_instances: NUM_PARALLEL_WEIGHTS}

  - !ArrayContainer # Each row receives a different input. Rows share outputs.
    name: input_modulator
    <<<: [*container_defaults, *spatial_must_reuse_outputs]
    spatial: {meshY: NUM_WAVELENGTHS}
    constraints: {spatial: {maximize_dims: [C, R, S]}}
    max_utilization: {spatial: {factors: [('C=' + str(input_modulator.get_fanout()))]}} 

  - !Component # Row drivers feed inputs onto the rows of the array
    name: input_dac
    <<<: [*component_defaults, *keep_inputs, *no_coalesce]
    subclass: dac_lightning
    attributes: {width: DAC_RESOLUTION}

  - !Component # Row drivers feed inputs onto the rows of the array
    name: individual_modulator_placeholder
    <<<: [*component_defaults, *keep_inputs, *no_coalesce]
    subclass: lightning_modulator
    attributes: {width: DAC_RESOLUTION}

  - !ArrayContainer # Each row receives a different input. Rows share outputs.
    name: virtualized_modulator
    <<<: [*container_defaults, *spatial_must_reuse_outputs]
    spatial: {meshY: NUM_WAVELENGTHS}
    constraints: {spatial: {maximize_dims: [C, R, S]}}
    max_utilization: {spatial: {factors: [('C=' + str(virtualized_modulator.get_fanout()))]}}
  
  - !Hierarchical           # Virtualize an XxYxZ-bit MAC as multiple MAC units.
    nodes: *virtualized_modulator # Defined in include/defines.yaml.
